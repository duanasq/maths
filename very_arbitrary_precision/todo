[x] move into dir
[x] learn about python modules
[x] create separate module 
[x] separate tests
[x] separate Anum tests
[x] create class file and import module
[x] represent fractional part
[x] add with fractional part
  [x] refactor rippleCarry to return the carry
  [x] see where anum tests are at
  [x] refactor add to return the carry
  [x] refactor anum to prepend the carry
  [x] create build script
  [x] change add to zip_add
    [x] add tests to see what happens if diff lengths
  [x] move add tests to anum test
    [x] decide how to treat empty arrays
    [x] add test for abitrary precision
  [x] refactor add to take padding direction
  [x] implement fractional adding with these
    [x] change zip_add to take more than 2 args
    [x] be able to prepend / append for all operands
    [x] refactor to use map
  [x] anum can add fractions, add the carry, then add the whole numbers, then prepend the carry
    [x] get test to work
[x] multiplication
  [x] whole numbers
    [x] perf test
      [x] separate test class
    [x] test for swapping operands for performance
    [x] skip zeroes for performance
  [x] fractional parts
    [x] implement div by ten
      [x] munch trailing zeroes
    [x] move munching of trailing zeroes to anum constructor
    [x] test all ec cases
    [x] add a big testcase
[x] remove leading zeroes in anum constructor
[x] find out how many digits of sqrt 2 I can print using float/double whatever - 16
[ ] print arbitrary precision of sqrt 2
  [ ] implement digbydig sqrt algorithm with arbitrary precision
    [ ] move module out of test file
[ ] understand, with some experiments, IEEE floats
[ ] print statements that tell me which digit it is evaluating

[ ] read https://rushter.com/blog/python-integer-implementation/
[ ] read https://docs.python.org/3/tutorial/floatingpoint.html

